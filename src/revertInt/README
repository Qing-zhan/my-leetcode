提示：假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。

1. 关于有符号整数的取值范围
对于位长为 n 个字节，其可以表示的
有符号整数取值范围：- 2^(n-1) ~ 2^(n-1) - 1
无符号整数取值范围：0 ~ 2^(n-1) - 1
e.g. 4bit [-8, 7]
0111	 7
0110	 6
0101	 5
0100	 4
0011	 3
0010	 2
0001	 1
0000	 0
1111	-1
1110	-2
1101	-3
1100	-4
1011	-5
1010	-6
1001	-7
1000	-8

正常情况下，反码与补码的转换计算方式为：
	反码 = 补码非符号位取反 + 1 
	补码 = 反码非符号位取反 + 1 
但是特殊情况出现在 1111 的计算，一种可行的解释是：-8(反码) = 11000
11000
10111
11000
但是由于位数为4，去掉非符号位的溢出位，则为 1000；这也是 4bit 数避免同时用两个补码表示0造成的浪费；

2. INT_MAX & INT_MIN
C++中，sizeof(int) = 4, 即 4bit 表示整数；INT_MAX = 2147483647, INT_MIN = -2147483648；